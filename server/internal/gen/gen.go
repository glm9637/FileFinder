//go:build go1.22

// Package gen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gen

import (
	"fmt"
	"net/http"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// Defines values for FileSystemType.
const (
	File   FileSystemType = "file"
	Folder FileSystemType = "folder"
)

// Article defines model for Article.
type Article struct {
	// Files The folder structure found in the articles folder
	Files *[]FileSystem `json:"files,omitempty"`

	// Number Article number
	Number *string `json:"number,omitempty"`
}

// BOM defines model for BOM.
type BOM struct {
	Materials *[]Material `json:"materials,omitempty"`

	// Name the name of the article
	Name *string `json:"name,omitempty"`
}

// FileSystem defines model for FileSystem.
type FileSystem struct {
	Children *[]FileSystem `json:"children,omitempty"`

	// Name the current folder name
	Name *string `json:"name,omitempty"`

	// Path the path to the folder
	Path *string         `json:"path,omitempty"`
	Type *FileSystemType `json:"type,omitempty"`
}

// FileSystemType defines model for FileSystem.Type.
type FileSystemType string

// FullBom defines model for FullBom.
type FullBom struct {
	Children *[]FullBom `json:"children,omitempty"`

	// Name the name of the article
	Name *string `json:"name,omitempty"`

	// Number the article number
	Number *string `json:"number,omitempty"`
}

// Material defines model for Material.
type Material struct {
	// Name the name of the article
	Name *string `json:"name,omitempty"`

	// Number the article number
	Number *string `json:"number,omitempty"`
}

// UploadFileMultipartBody defines parameters for UploadFile.
type UploadFileMultipartBody struct {
	Photo *openapi_types.File `json:"photo,omitempty"`
}

// UploadFileMultipartRequestBody defines body for UploadFile for multipart/form-data" ContentType.
type UploadFileMultipartRequestBody UploadFileMultipartBody

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Query a article
	// (GET /article/{number})
	GetArticle(w http.ResponseWriter, r *http.Request, number string)
	// get a bom of the article
	// (GET /article/{number}/bom)
	GetBom(w http.ResponseWriter, r *http.Request, number string)
	// get the full bom of the article
	// (GET /article/{number}/bom/full)
	GetFullBom(w http.ResponseWriter, r *http.Request, number string)
	// get the default file for the article
	// (GET /article/{number}/file)
	GetArticleFile(w http.ResponseWriter, r *http.Request, number string)
	// uploads a new file to the specified article
	// (POST /article/{number}/file)
	UploadFile(w http.ResponseWriter, r *http.Request, number string)
	// get the specified file
	// (GET /article/{number}/file/{path})
	GetFile(w http.ResponseWriter, r *http.Request, number string, path string)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// GetArticle operation middleware
func (siw *ServerInterfaceWrapper) GetArticle(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "number" -------------
	var number string

	err = runtime.BindStyledParameterWithOptions("simple", "number", r.PathValue("number"), &number, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "number", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetArticle(w, r, number)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetBom operation middleware
func (siw *ServerInterfaceWrapper) GetBom(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "number" -------------
	var number string

	err = runtime.BindStyledParameterWithOptions("simple", "number", r.PathValue("number"), &number, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "number", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBom(w, r, number)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFullBom operation middleware
func (siw *ServerInterfaceWrapper) GetFullBom(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "number" -------------
	var number string

	err = runtime.BindStyledParameterWithOptions("simple", "number", r.PathValue("number"), &number, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "number", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFullBom(w, r, number)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetArticleFile operation middleware
func (siw *ServerInterfaceWrapper) GetArticleFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "number" -------------
	var number string

	err = runtime.BindStyledParameterWithOptions("simple", "number", r.PathValue("number"), &number, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "number", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetArticleFile(w, r, number)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UploadFile operation middleware
func (siw *ServerInterfaceWrapper) UploadFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "number" -------------
	var number string

	err = runtime.BindStyledParameterWithOptions("simple", "number", r.PathValue("number"), &number, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "number", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadFile(w, r, number)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetFile operation middleware
func (siw *ServerInterfaceWrapper) GetFile(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "number" -------------
	var number string

	err = runtime.BindStyledParameterWithOptions("simple", "number", r.PathValue("number"), &number, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "number", Err: err})
		return
	}

	// ------------- Path parameter "path" -------------
	var path string

	err = runtime.BindStyledParameterWithOptions("simple", "path", r.PathValue("path"), &path, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "path", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetFile(w, r, number, path)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/article/{number}", wrapper.GetArticle)
	m.HandleFunc("GET "+options.BaseURL+"/article/{number}/bom", wrapper.GetBom)
	m.HandleFunc("GET "+options.BaseURL+"/article/{number}/bom/full", wrapper.GetFullBom)
	m.HandleFunc("GET "+options.BaseURL+"/article/{number}/file", wrapper.GetArticleFile)
	m.HandleFunc("POST "+options.BaseURL+"/article/{number}/file", wrapper.UploadFile)
	m.HandleFunc("GET "+options.BaseURL+"/article/{number}/file/{path}", wrapper.GetFile)

	return m
}
